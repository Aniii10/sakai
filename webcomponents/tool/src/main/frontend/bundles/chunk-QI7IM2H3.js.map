{
  "version": 3,
  "sources": ["../node_modules/@lion/overlays/src/globalOverlaysStyle.js", "../node_modules/@lion/overlays/src/utils/inert-siblings.js", "../node_modules/@lion/overlays/src/OverlaysManager.js", "../node_modules/@lion/overlays/src/overlays.js", "../node_modules/@lion/overlays/src/utils/get-deep-active-element.js", "../node_modules/@lion/overlays/src/utils/is-visible.js", "../node_modules/@lion/overlays/src/utils/sort-by-tabindex.js", "../node_modules/@lion/overlays/src/utils/get-focusable-elements.js", "../node_modules/@lion/overlays/src/utils/deep-contains.js", "../node_modules/@lion/overlays/src/utils/key-codes.js", "../node_modules/@lion/overlays/src/utils/contain-focus.js", "../node_modules/@lion/overlays/src/OverlayController.js", "../node_modules/@lion/overlays/src/utils/is-equal-config.js", "../node_modules/@lion/overlays/src/OverlayMixin.js", "../node_modules/@lion/overlays/src/configurations/withModalDialogConfig.js", "../node_modules/@lion/dialog/src/LionDialog.js", "../node_modules/@lion/dialog/lion-dialog.js"],
  "sourcesContent": ["import { css } from '@lion/core';\n\nexport const globalOverlaysStyle = css`\n  .global-overlays {\n    position: fixed;\n    z-index: 200;\n  }\n\n  .global-overlays__overlay {\n    pointer-events: auto;\n  }\n\n  .global-overlays__overlay-container {\n    display: flex;\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    pointer-events: none;\n  }\n\n  .global-overlays__overlay-container--top-left {\n    justify-content: flex-start;\n    align-items: flex-start;\n  }\n\n  .global-overlays__overlay-container--top {\n    justify-content: center;\n    align-items: flex-start;\n  }\n\n  .global-overlays__overlay-container--top-right {\n    justify-content: flex-end;\n    align-items: flex-start;\n  }\n\n  .global-overlays__overlay-container--right {\n    justify-content: flex-end;\n    align-items: center;\n  }\n\n  .global-overlays__overlay-container--bottom-left {\n    justify-content: flex-start;\n    align-items: flex-end;\n  }\n\n  .global-overlays__overlay-container--bottom {\n    justify-content: center;\n    align-items: flex-end;\n  }\n\n  .global-overlays__overlay-container--bottom-right {\n    justify-content: flex-end;\n    align-items: flex-end;\n  }\n  .global-overlays__overlay-container--left {\n    justify-content: flex-start;\n    align-items: center;\n  }\n\n  .global-overlays__overlay-container--center {\n    justify-content: center;\n    align-items: center;\n  }\n\n  .global-overlays__overlay--bottom-sheet {\n    width: 100%;\n  }\n\n  .global-overlays .global-overlays__backdrop {\n    content: '';\n    position: fixed;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n    z-index: -1;\n    background-color: #333333;\n    filter: opacity(30%);\n    display: none;\n  }\n\n  .global-overlays .global-overlays__backdrop--visible {\n    display: block;\n  }\n\n  .global-overlays .global-overlays__backdrop--animation-in {\n    animation: global-overlays-backdrop-fade-in 300ms;\n  }\n\n  .global-overlays .global-overlays__backdrop--animation-out {\n    animation: global-overlays-backdrop-fade-out 300ms;\n    opacity: 0;\n  }\n\n  @keyframes global-overlays-backdrop-fade-in {\n    from {\n      opacity: 0;\n    }\n  }\n\n  @keyframes global-overlays-backdrop-fade-out {\n    from {\n      opacity: 0.3;\n    }\n  }\n\n  body > *[inert] {\n    -webkit-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n    pointer-events: none;\n  }\n\n  body.global-overlays-scroll-lock {\n    overflow: hidden;\n  }\n\n  body.global-overlays-scroll-lock-ios-fix {\n    position: fixed;\n    width: 100%;\n  }\n\n  html.global-overlays-scroll-lock-ios-fix {\n    height: 100vh;\n  }\n`;\n", "/**\n * Use the [inert] attribute to be forwards compatible with: https://html.spec.whatwg.org/multipage/interaction.html#inert\n */\n\n/**\n * Makes sibling elements inert, sets the inert attribute and aria-hidden for\n * screen readers.\n * @param {HTMLElement} element\n */\nexport function setSiblingsInert(element) {\n  const parentChildren = /** @type {HTMLCollection} */ (element.parentElement?.children);\n  for (let i = 0; i < parentChildren.length; i += 1) {\n    const sibling = parentChildren[i];\n\n    if (sibling !== element) {\n      sibling.setAttribute('inert', '');\n      sibling.setAttribute('aria-hidden', 'true');\n    }\n  }\n}\n\n/**\n * Removes inert and aria-hidden attribute from sibling elements\n * @param {HTMLElement} element\n */\nexport function unsetSiblingsInert(element) {\n  const parentChildren = /** @type {HTMLCollection} */ (element.parentElement?.children);\n  for (let i = 0; i < parentChildren.length; i += 1) {\n    const sibling = parentChildren[i];\n\n    if (sibling !== element) {\n      sibling.removeAttribute('inert');\n      sibling.removeAttribute('aria-hidden');\n    }\n  }\n}\n", "import { unsetSiblingsInert, setSiblingsInert } from './utils/inert-siblings.js';\nimport { globalOverlaysStyle } from './globalOverlaysStyle.js';\n\n/**\n * @typedef {import('@lion/core').CSSResult} CSSResult\n * @typedef {import('./OverlayController.js').OverlayController} OverlayController\n */\n\nconst isIOS = navigator.userAgent.match(/iPhone|iPad|iPod/i);\n\n/**\n * `OverlaysManager` which manages overlays which are rendered into the body\n */\nexport class OverlaysManager {\n  static __createGlobalRootNode() {\n    const rootNode = document.createElement('div');\n    rootNode.classList.add('global-overlays');\n    document.body.appendChild(rootNode);\n    return rootNode;\n  }\n\n  static __createGlobalStyleNode() {\n    const styleTag = document.createElement('style');\n    styleTag.setAttribute('data-global-overlays', '');\n    styleTag.textContent = /** @type {CSSResult} */ (globalOverlaysStyle).cssText;\n    document.head.appendChild(styleTag);\n    return styleTag;\n  }\n\n  /**\n   * no setter as .list is intended to be read-only\n   * You can use .add or .remove to modify it\n   */\n  // eslint-disable-next-line class-methods-use-this\n  get globalRootNode() {\n    if (!OverlaysManager.__globalRootNode) {\n      OverlaysManager.__globalRootNode = OverlaysManager.__createGlobalRootNode();\n      OverlaysManager.__globalStyleNode = OverlaysManager.__createGlobalStyleNode();\n    }\n    return OverlaysManager.__globalRootNode;\n  }\n\n  /**\n   * no setter as .list is intended to be read-only\n   * You can use .add or .remove to modify it\n   */\n  get list() {\n    return this.__list;\n  }\n\n  /**\n   * no setter as .shownList is intended to be read-only\n   * You can use .show or .hide on individual controllers to modify\n   */\n  get shownList() {\n    return this.__shownList;\n  }\n\n  constructor() {\n    /**\n     * @type {OverlayController[]}\n     * @private\n     */\n    this.__list = [];\n    /**\n     * @type {OverlayController[]}\n     * @private\n     */\n    this.__shownList = [];\n    /** @private */\n    this.__siblingsInert = false;\n    /**\n     * @type {WeakMap<OverlayController, OverlayController[]>}\n     * @private\n     */\n    this.__blockingMap = new WeakMap();\n  }\n\n  /**\n   * Registers an overlay controller.\n   * @param {OverlayController} ctrlToAdd controller of the newly added overlay\n   * @returns {OverlayController} same controller after adding to the manager\n   */\n  add(ctrlToAdd) {\n    if (this.list.find(ctrl => ctrlToAdd === ctrl)) {\n      throw new Error('controller instance is already added');\n    }\n    this.list.push(ctrlToAdd);\n    return ctrlToAdd;\n  }\n\n  /**\n   * @param {OverlayController} ctrlToRemove\n   */\n  remove(ctrlToRemove) {\n    if (!this.list.find(ctrl => ctrlToRemove === ctrl)) {\n      throw new Error('could not find controller to remove');\n    }\n    this.__list = this.list.filter(ctrl => ctrl !== ctrlToRemove);\n  }\n\n  /**\n   * @param {OverlayController} ctrlToShow\n   */\n  show(ctrlToShow) {\n    if (this.list.find(ctrl => ctrlToShow === ctrl)) {\n      this.hide(ctrlToShow);\n    }\n    this.__shownList.unshift(ctrlToShow);\n\n    // make sure latest shown ctrl is visible\n    Array.from(this.__shownList)\n      .reverse()\n      .forEach((ctrl, i) => {\n        // eslint-disable-next-line no-param-reassign\n        ctrl.elevation = i + 1;\n      });\n  }\n\n  /**\n   * @param {any} ctrlToHide\n   */\n  hide(ctrlToHide) {\n    if (!this.list.find(ctrl => ctrlToHide === ctrl)) {\n      throw new Error('could not find controller to hide');\n    }\n    this.__shownList = this.shownList.filter(ctrl => ctrl !== ctrlToHide);\n  }\n\n  teardown() {\n    this.list.forEach(ctrl => {\n      ctrl.teardown();\n    });\n\n    this.__list = [];\n    this.__shownList = [];\n    this.__siblingsInert = false;\n\n    const rootNode = OverlaysManager.__globalRootNode;\n    if (rootNode) {\n      if (rootNode.parentElement) {\n        rootNode.parentElement.removeChild(rootNode);\n      }\n      OverlaysManager.__globalRootNode = undefined;\n\n      document.head.removeChild(\n        /** @type {HTMLStyleElement} */ (OverlaysManager.__globalStyleNode),\n      );\n      OverlaysManager.__globalStyleNode = undefined;\n    }\n  }\n\n  /** Features right now only for Global Overlay Manager */\n\n  get siblingsInert() {\n    return this.__siblingsInert;\n  }\n\n  disableTrapsKeyboardFocusForAll() {\n    this.shownList.forEach(ctrl => {\n      if (ctrl.trapsKeyboardFocus === true && ctrl.disableTrapsKeyboardFocus) {\n        ctrl.disableTrapsKeyboardFocus({ findNewTrap: false });\n      }\n    });\n  }\n\n  /**\n   * @param {'local' | 'global' | undefined} placementMode\n   */\n  informTrapsKeyboardFocusGotEnabled(placementMode) {\n    if (this.siblingsInert === false && placementMode === 'global') {\n      if (OverlaysManager.__globalRootNode) {\n        setSiblingsInert(this.globalRootNode);\n      }\n      this.__siblingsInert = true;\n    }\n  }\n\n  /**\n   * @param {{ disabledCtrl?:OverlayController, findNewTrap?:boolean }} [options]\n   */\n  informTrapsKeyboardFocusGotDisabled({ disabledCtrl, findNewTrap = true } = {}) {\n    const next = this.shownList.find(\n      ctrl => ctrl !== disabledCtrl && ctrl.trapsKeyboardFocus === true,\n    );\n    if (next) {\n      if (findNewTrap) {\n        next.enableTrapsKeyboardFocus();\n      }\n    } else if (this.siblingsInert === true) {\n      if (OverlaysManager.__globalRootNode) {\n        unsetSiblingsInert(this.globalRootNode);\n      }\n      this.__siblingsInert = false;\n    }\n  }\n\n  /** PreventsScroll */\n\n  // eslint-disable-next-line class-methods-use-this\n  requestToPreventScroll() {\n    // no check as classList will dedupe it anyways\n    document.body.classList.add('global-overlays-scroll-lock');\n    if (isIOS) {\n      // iOS has issues with overlays with input fields. This is fixed by applying\n      // position: fixed to the body. As a side effect, this will scroll the body to the top.\n      document.body.classList.add('global-overlays-scroll-lock-ios-fix');\n      document.documentElement.classList.add('global-overlays-scroll-lock-ios-fix');\n    }\n  }\n\n  requestToEnableScroll() {\n    if (!this.shownList.some(ctrl => ctrl.preventsScroll === true)) {\n      document.body.classList.remove('global-overlays-scroll-lock');\n      if (isIOS) {\n        document.body.classList.remove('global-overlays-scroll-lock-ios-fix');\n        document.documentElement.classList.remove('global-overlays-scroll-lock-ios-fix');\n      }\n    }\n  }\n\n  /**\n   * Blocking\n   * @param {OverlayController} blockingCtrl\n   */\n  requestToShowOnly(blockingCtrl) {\n    const controllersToHide = this.shownList.filter(ctrl => ctrl !== blockingCtrl);\n\n    controllersToHide.map(ctrl => ctrl.hide());\n    this.__blockingMap.set(blockingCtrl, controllersToHide);\n  }\n\n  /**\n   * @param {OverlayController} blockingCtrl\n   */\n  retractRequestToShowOnly(blockingCtrl) {\n    if (this.__blockingMap.has(blockingCtrl)) {\n      const controllersWhichGotHidden = /** @type {OverlayController[]} */ (\n        this.__blockingMap.get(blockingCtrl)\n      );\n      controllersWhichGotHidden.map(ctrl => ctrl.show());\n    }\n  }\n}\n/** @type {HTMLElement | undefined} */\nOverlaysManager.__globalRootNode = undefined;\n/** @type {HTMLStyleElement | undefined} */\nOverlaysManager.__globalStyleNode = undefined;\n", "import { singletonManager } from 'singleton-manager';\n// eslint-disable-next-line import/no-cycle\nimport { OverlaysManager } from './OverlaysManager.js';\n\n// eslint-disable-next-line import/no-mutable-exports\nexport let overlays =\n  singletonManager.get('@lion/overlays::overlays::0.15.x') || new OverlaysManager();\n\n/**\n * @param {OverlaysManager} newOverlays\n */\nexport function setOverlays(newOverlays) {\n  overlays = newOverlays;\n}\n", "/**\n * Returns the activeElement, even when they are inside a shadowRoot.\n * (If an element in a shadowRoot is focused, document.activeElement\n * returns the shadowRoot host.\n *\n * @returns {Element}\n */\nexport function getDeepActiveElement() {\n  let host = document.activeElement || document.body;\n  while (host && host.shadowRoot && host.shadowRoot.activeElement) {\n    host = host.shadowRoot.activeElement;\n  }\n  return host;\n}\n", "/**\n * @param {CSSStyleDeclaration} styles\n */\nconst hasStyleVisibility = ({ visibility, display }) =>\n  visibility !== 'hidden' && display !== 'none';\n\n/**\n * @param {CSSStyleDeclaration} styles\n */\nconst isDisplayContents = ({ display }) => display === 'contents';\n\n/**\n * @param {HTMLElement} element\n * @returns {boolean} Whether the element is visible\n */\nexport function isVisible(element) {\n  if (!element) {\n    return false;\n  }\n\n  // Check if element is connected to the DOM\n  if (!element.isConnected) {\n    return false;\n  }\n\n  // Check inline styles to avoid a reflow\n  // matches display: none, visibility: hidden on element\n  if (!hasStyleVisibility(element.style)) {\n    return false;\n  }\n\n  const computedStyle = window.getComputedStyle(element);\n\n  // Check computed styles\n  // matches display: none, visibility: hidden on element and visibility: hidden from parent\n  if (!hasStyleVisibility(computedStyle)) {\n    return false;\n  }\n\n  // Allow element that delegates layout (i.e. display: contents)\n  // matches display: contents\n  if (isDisplayContents(computedStyle)) {\n    return true;\n  }\n\n  // display: none is not inherited, so finally check if element has calculated width or height\n  // matches display: none from parent\n  return !!(element.offsetWidth || element.offsetHeight || element.getClientRects().length);\n}\n", "/**\n * Implementation based on:\n * https://github.com/PolymerElements/iron-overlay-behavior/blob/master/iron-focusables-helper.html\n * The original implementation does not work for non-Polymer web components, and contains several\n * bugs on IE11.\n */\n\n/**\n * @param {HTMLElement} a\n * @param {HTMLElement} b\n * @returns {Boolean}\n */\nfunction hasLowerTabOrder(a, b) {\n  // Normalize tabIndexes\n  // e.g. in Firefox `<div contenteditable>` has `tabIndex = -1`\n  const ati = Math.max(a.tabIndex, 0);\n  const bti = Math.max(b.tabIndex, 0);\n  return ati === 0 || bti === 0 ? bti > ati : ati > bti;\n}\n\n/**\n * @param {HTMLElement[]} left\n * @param {HTMLElement[]} right\n * @returns {HTMLElement[]}\n */\nfunction mergeSortByTabIndex(left, right) {\n  /** @type {HTMLElement[]} */\n  const result = [];\n  while (left.length > 0 && right.length > 0) {\n    if (hasLowerTabOrder(left[0], right[0])) {\n      result.push(/** @type {HTMLElement} */ (right.shift()));\n    } else {\n      result.push(/** @type {HTMLElement} */ (left.shift()));\n    }\n  }\n\n  return [...result, ...left, ...right];\n}\n\n/**\n * @param {HTMLElement[]} elements\n * @returns {HTMLElement[]}\n */\nexport function sortByTabIndex(elements) {\n  // Implement a merge sort as Array.prototype.sort does a non-stable sort\n  // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort\n  const len = elements.length;\n  if (len < 2) {\n    return elements;\n  }\n\n  const pivot = Math.ceil(len / 2);\n  const left = sortByTabIndex(elements.slice(0, pivot));\n  const right = sortByTabIndex(elements.slice(pivot));\n  return mergeSortByTabIndex(left, right);\n}\n", "/**\n * Implementation based on: https://github.com/PolymerElements/iron-overlay-behavior/blob/master/iron-focusables-helper.html\n * The original implementation does not work for non-Polymer web components,\n * and contains several bugs on IE11.\n */\n\nimport { isVisible } from './is-visible.js';\nimport { sortByTabIndex } from './sort-by-tabindex.js';\n\n// IE11 supports matches as 'msMatchesSelector'\nconst matchesFunc = 'matches' in Element.prototype ? 'matches' : 'msMatchesSelector';\n\n/**\n * @param {HTMLElement} element\n * @returns {boolean} Whether the element matches\n */\nfunction isFocusable(element) {\n  // Elements that cannot be focused if they have [disabled] attribute.\n  if (element[matchesFunc]('input, select, textarea, button, object')) {\n    return element[matchesFunc](':not([disabled])');\n  }\n\n  // Elements that can be focused even if they have [disabled] attribute.\n  return element[matchesFunc]('a[href], area[href], iframe, [tabindex], [contentEditable]');\n}\n\n/**\n * @param {HTMLElement} element\n * @returns {Number}\n */\nfunction getTabindex(element) {\n  if (isFocusable(element)) {\n    return Number(element.getAttribute('tabindex') || 0);\n  }\n  return -1;\n}\n\n/**\n * @param {HTMLElement|HTMLSlotElement} element\n */\nfunction getChildNodes(element) {\n  if (element.localName === 'slot') {\n    const slot = /** @type {HTMLSlotElement} */ (element);\n    return slot.assignedNodes({ flatten: true });\n  }\n\n  const { children } = element.shadowRoot || element;\n  // On IE11, SVGElement.prototype.children is undefined\n  return children || [];\n}\n\n/**\n * @param {Element} element\n * @returns {boolean}\n */\nfunction isVisibleElement(element) {\n  if (element.nodeType !== Node.ELEMENT_NODE) {\n    return false;\n  }\n\n  // A slot is not visible, but it's children might so we need\n  // to treat is as such.\n  if (element.localName === 'slot') {\n    return true;\n  }\n\n  return isVisible(/** @type {HTMLElement} */ (element));\n}\n\n/**\n * Recursive function that traverses the children of the target node and finds\n * elements that can receive focus. Mutates the nodes property for performance.\n *\n * @param {Element} element\n * @param {HTMLElement[]} nodes\n * @returns {boolean} whether the returned node list should be sorted. This happens when\n *                    there is an element with tabindex > 0\n */\nfunction collectFocusableElements(element, nodes) {\n  // If not an element or not visible, no need to explore children.\n  if (!isVisibleElement(element)) {\n    return false;\n  }\n\n  const el = /** @type {HTMLElement} */ (element);\n  const tabIndex = getTabindex(el);\n  let needsSort = tabIndex > 0;\n  if (tabIndex >= 0) {\n    nodes.push(el);\n  }\n\n  const childNodes = /** @type {Element[]} */ (getChildNodes(el));\n  for (let i = 0; i < childNodes.length; i += 1) {\n    needsSort = collectFocusableElements(childNodes[i], nodes) || needsSort;\n  }\n  return needsSort;\n}\n\n/**\n * @param {Element} element\n * @returns {HTMLElement[]}\n */\nexport function getFocusableElements(element) {\n  /** @type {HTMLElement[]} */\n  const nodes = [];\n\n  const needsSort = collectFocusableElements(element, nodes);\n  return needsSort ? sortByTabIndex(nodes) : nodes;\n}\n", "/**\n * Whether first element contains the second element, also goes through shadow roots\n * @param {HTMLElement|ShadowRoot} el\n * @param {HTMLElement|ShadowRoot} targetEl\n * @returns {boolean}\n */\nexport function deepContains(el, targetEl) {\n  let containsTarget = el.contains(targetEl);\n  if (containsTarget) {\n    return true;\n  }\n\n  /** @param {HTMLElement|ShadowRoot} elem */\n  function checkChildren(elem) {\n    for (let i = 0; i < elem.children.length; i += 1) {\n      const child = /** @type {HTMLElement}  */ (elem.children[i]);\n      if (child.shadowRoot && deepContains(child.shadowRoot, targetEl)) {\n        containsTarget = true;\n        break;\n      }\n      if (child.children.length > 0) {\n        checkChildren(child);\n      }\n    }\n  }\n\n  // If element is not shadowRoot itself\n  if (el instanceof HTMLElement && el.shadowRoot) {\n    containsTarget = deepContains(el.shadowRoot, targetEl);\n    if (containsTarget) {\n      return true;\n    }\n  }\n  checkChildren(el);\n  return containsTarget;\n}\n", "export const keyCodes = {\n  enter: 13,\n  space: 32,\n  escape: 27,\n  tab: 9,\n};\n", "/* eslint-disable no-param-reassign */\n\n/**\n * Implementation based on: https://github.com/PolymerElements/iron-overlay-behavior/blob/master/iron-focusables-helper.html\n * The original implementation does not work for non-Polymer web components,\n * and contains several bugs on IE11.\n */\n\nimport { getDeepActiveElement } from './get-deep-active-element.js';\nimport { getFocusableElements } from './get-focusable-elements.js';\nimport { deepContains } from './deep-contains.js';\nimport { keyCodes } from './key-codes.js';\n\n/**\n * Rotates focus within a list of elements. If shift key was not pressed and focus\n * is on last item, puts focus on the first item. Reversed if shift key.\n *\n * @param {HTMLElement} rootElement The root element\n * @param {KeyboardEvent} e The keyboard event\n */\nexport function rotateFocus(rootElement, e) {\n  // Find focusable elements\n  const els = getFocusableElements(rootElement);\n  // Determine the focus rotation boundaries.\n  let boundaryEls;\n\n  // If more than two elements, take the first and last\n  if (els.length >= 2) {\n    boundaryEls = [els[0], els[els.length - 1]];\n\n    // If 1 element, it is the boundary\n  } else if (els.length === 1) {\n    boundaryEls = [els[0], els[0]];\n\n    // If no focusable elements, root becomes the boundary\n  } else {\n    boundaryEls = [rootElement, rootElement];\n  }\n\n  // Reverse direction of boundaries if shift key was pressed\n  if (e.shiftKey) {\n    boundaryEls.reverse();\n  }\n\n  // Take first and last elements within boundary\n  const [first, last] = boundaryEls;\n\n  // Get the currently focused element\n  const activeElement = /** @type {HTMLElement} */ (getDeepActiveElement());\n\n  /**\n   * If currently focused on the root element or an element contained within the root element:\n   * allow native browser behavior (tab to the next node in DOM order).\n   *\n   * If currently focused on the last focusable element within the root element, or on an element\n   * outside of the root element: redirect focus to the first focusable element.\n   */\n  if (activeElement === rootElement || (els.includes(activeElement) && last !== activeElement)) {\n    return;\n  }\n\n  e.preventDefault();\n  first.focus();\n}\n\n/**\n * Contains focus within given root element. When focus is on the last focusable\n * element inside the root element, the next focus will be redirected to the first\n * focusable element.\n *\n * @param {HTMLElement} rootElement The element to contain focus within\n * @returns {{ disconnect: () => void }} handler with a disconnect callback\n */\nexport function containFocus(rootElement) {\n  const focusableElements = getFocusableElements(rootElement);\n  // Initial focus goes to first element with autofocus, or the root element\n  const initialFocus = focusableElements.find(e => e.hasAttribute('autofocus')) || rootElement;\n  /** @type {HTMLElement} */\n  let tabDetectionElement;\n  /** @type {MutationObserver} */\n  let rootElementMutationObserver;\n\n  // If root element will receive focus, it should have a tabindex of -1.\n  // This makes it focusable through js, but it won't appear in the tab order\n  if (initialFocus === rootElement) {\n    rootElement.tabIndex = -1;\n    rootElement.style.setProperty('outline', 'none');\n  }\n\n  // Focus first focusable element\n  initialFocus.focus();\n\n  /**\n   * Ensures focus stays inside root element on tab\n   * @param {KeyboardEvent} e\n   */\n  function handleKeydown(e) {\n    if (e.keyCode === keyCodes.tab) {\n      rotateFocus(rootElement, e);\n    }\n  }\n\n  function createHelpersDetectingTabDirection() {\n    tabDetectionElement = document.createElement('div');\n    tabDetectionElement.style.display = 'none';\n    tabDetectionElement.setAttribute('data-is-tab-detection-element', '');\n    rootElement.insertBefore(tabDetectionElement, rootElement.children[0]);\n\n    rootElementMutationObserver = new MutationObserver(mutationsList => {\n      for (const mutation of mutationsList) {\n        if (mutation.type === 'childList') {\n          const tabDetectionElIsMissing = !Array.from(rootElement.children).find(el =>\n            el.hasAttribute('data-is-tab-detection-element'),\n          );\n          const foundTabDetectionElInMutations = Array.from(mutation.addedNodes).find(\n            /** @param {Node} el */ el =>\n              el instanceof HTMLElement && el.hasAttribute('data-is-tab-detection-element'),\n          );\n          // Prevent infinite loop by detecting that mutation event is not from adding the tab detection el\n          if (tabDetectionElIsMissing && !foundTabDetectionElInMutations) {\n            rootElementMutationObserver.disconnect();\n            createHelpersDetectingTabDirection();\n          }\n        }\n      }\n    });\n    rootElementMutationObserver.observe(rootElement, { childList: true });\n  }\n\n  function isForwardTabInWindow() {\n    const compareMask = tabDetectionElement.compareDocumentPosition(\n      /** @type {Element} */ (document.activeElement),\n    );\n    return compareMask === Node.DOCUMENT_POSITION_PRECEDING;\n  }\n\n  /**\n   * @param {Object} [opts]\n   * @param {boolean} [opts.resetToRoot]\n   * @desc When we simulate a modal dialog, we need to restore the focus to the first or last\n   * element of the rootElement\n   */\n  function setFocusInRootElement({ resetToRoot = false } = {}) {\n    if (deepContains(rootElement, /** @type {HTMLElement} */ (getDeepActiveElement()))) {\n      return;\n    }\n\n    let nextActive;\n    if (resetToRoot) {\n      nextActive = rootElement;\n    } else {\n      nextActive = focusableElements[isForwardTabInWindow() ? 0 : focusableElements.length - 1];\n    }\n\n    if (nextActive) {\n      nextActive.focus();\n    }\n  }\n\n  function handleFocusin() {\n    window.removeEventListener('focusin', handleFocusin);\n    setFocusInRootElement();\n  }\n\n  function handleFocusout() {\n    /**\n     * There is a moment in time between focusout and focusin (when focus shifts)\n     * where the activeElement is reset to body first. So we use an async task to check\n     * a little bit later for activeElement, so we don't get a false positive.\n     *\n     * We used to check for focusin event for this, however,\n     * it can happen that focusout happens, but focusin never does, e.g. click outside but no focusable\n     * element is found to focus. If this happens, we should take the focus back to the rootElement.\n     */\n    setTimeout(() => {\n      if (!deepContains(rootElement, /** @type {HTMLElement} */ (getDeepActiveElement()))) {\n        setFocusInRootElement({ resetToRoot: true });\n      }\n    });\n\n    window.addEventListener('focusin', handleFocusin);\n  }\n\n  function disconnect() {\n    window.removeEventListener('keydown', handleKeydown);\n    window.removeEventListener('focusin', handleFocusin);\n    window.removeEventListener('focusout', handleFocusout);\n    // Guard this, since we also disconnect if we notice a missing tab\n    // detection element. We reinsert it, so it's okay to not fail here.\n    rootElementMutationObserver.disconnect();\n    if (Array.from(rootElement.children).includes(tabDetectionElement)) {\n      rootElement.removeChild(tabDetectionElement);\n    }\n    rootElement.style.removeProperty('outline');\n  }\n\n  window.addEventListener('keydown', handleKeydown);\n  window.addEventListener('focusout', handleFocusout);\n  createHelpersDetectingTabDirection();\n\n  return { disconnect };\n}\n", "import { EventTargetShim } from '@lion/core';\n// eslint-disable-next-line import/no-cycle\nimport { overlays } from './overlays.js';\nimport { containFocus } from './utils/contain-focus.js';\n\n/**\n * @typedef {import('../types/OverlayConfig').OverlayConfig} OverlayConfig\n * @typedef {import('../types/OverlayConfig').ViewportConfig} ViewportConfig\n * @typedef {import('@popperjs/core/lib/popper').createPopper} Popper\n * @typedef {import('@popperjs/core/lib/popper').Options} PopperOptions\n * @typedef {import('@popperjs/core/lib/enums').Placement} Placement\n * @typedef {{ createPopper: Popper }} PopperModule\n * @typedef {'setup'|'init'|'teardown'|'before-show'|'show'|'hide'|'add'|'remove'} OverlayPhase\n */\n\n/**\n * @returns {Promise<PopperModule>}\n */\nasync function preloadPopper() {\n  // @ts-ignore [external]: import complains about untyped module, but we typecast it ourselves\n  return /** @type {* & Promise<PopperModule>} */ (import('@popperjs/core/dist/esm/popper.js'));\n}\n\nconst GLOBAL_OVERLAYS_CONTAINER_CLASS = 'global-overlays__overlay-container';\nconst GLOBAL_OVERLAYS_CLASS = 'global-overlays__overlay';\n// @ts-expect-error [external]: CSS not yet typed\nconst supportsCSSTypedObject = window.CSS?.number && document.body.attributeStyleMap?.set;\n\n/**\n * @desc OverlayController is the fundament for every single type of overlay. With the right\n * configuration, it can be used to build (modal) dialogs, tooltips, dropdowns, popovers,\n * bottom/top/left/right sheets etc.\n *\n * ### About contentNode, contentWrapperNode and renderTarget.\n *\n * #### contentNode\n * Node containing actual overlay contents.\n * It will not be touched by the OverlayController, it will only set attributes needed\n * for accessibility.\n *\n * #### contentWrapperNode\n * The 'positioning' element.\n * For local overlays, this node will be provided to Popper and all\n * inline positioning styles will be added here. It will also act as the container of an arrow\n * element (the arrow needs to be a sibling of contentNode for Popper to work correctly).\n * When projecting a contentNode from a shadowRoot, it is essential to have the wrapper in\n * shadow dom, so that contentNode can be styled via `::slotted` from the shadow root.\n * The Popper arrow can then be styled from that same shadow root as well.\n * For global overlays, the contentWrapperNode will be appended to the globalRootNode structure.\n *\n * #### renderTarget\n * Usually the parent node of contentWrapperNode that either exists locally or globally.\n * When a responsive scenario is created (in which we switch from global to local or vice versa)\n * we need to know where we should reappend contentWrapperNode (or contentNode in case it's projected)\n *\n * So a regular flow can be summarized as follows:\n * 1. Application Developer spawns an OverlayController with a contentNode reference\n * 2. OverlayController will create a contentWrapperNode around contentNode (or consumes when provided)\n * 3. contentWrapperNode will be appended to the right renderTarget\n *\n * There are subtle differences depending on the following factors:\n * - whether in global/local placement mode\n * - whether contentNode projected\n * - whether an arrow is provided\n *\n * This leads to the following possible combinations:\n * - [l1]. local + no content projection + no arrow\n * - [l2]. local +    content projection + no arrow\n * - [l3]. local + no content projection +    arrow\n * - [l4]. local +    content projection +    arrow\n * - [g1]. global\n *\n * #### html structure for a content projected node\n * <div id=\"contentWrapperNode\">\n *  <slot name=\"contentNode\"></slot>\n *  <div x-arrow></div>\n * </div>\n *\n * Structure above depicts [l4]\n * So in case of [l1] and [l3], the <slot> element would be a regular element\n * In case of [l1] and [l2], there would be no arrow.\n * Note that a contentWrapperNode should be provided for [l2], [l3] and [l4]\n * In case of a global overlay ([g1]), it's enough to provide just the contentNode.\n * In case of a local overlay or a responsive overlay switching from placementMode, one should\n * always configure as if it were a local overlay.\n */\nexport class OverlayController extends EventTargetShim {\n  /**\n   * @constructor\n   * @param {OverlayConfig} config initial config. Will be remembered as shared config\n   * when `.updateConfig()` is called.\n   */\n  constructor(config = {}, manager = overlays) {\n    super();\n    this.manager = manager;\n    /** @private */\n    this.__sharedConfig = config;\n\n    /**\n     * @type {OverlayConfig}\n     * @protected\n     */\n    this._defaultConfig = {\n      placementMode: undefined,\n      contentNode: config.contentNode,\n      contentWrapperNode: config.contentWrapperNode,\n      invokerNode: config.invokerNode,\n      backdropNode: config.backdropNode,\n      referenceNode: undefined,\n      elementToFocusAfterHide: config.invokerNode,\n      inheritsReferenceWidth: 'none',\n      hasBackdrop: false,\n      isBlocking: false,\n      preventsScroll: false,\n      trapsKeyboardFocus: false,\n      hidesOnEsc: false,\n      hidesOnOutsideEsc: false,\n      hidesOnOutsideClick: false,\n      isTooltip: false,\n      invokerRelation: 'description',\n      // handlesUserInteraction: false,\n      handlesAccessibility: false,\n      popperConfig: {\n        placement: 'top',\n        strategy: 'absolute',\n        modifiers: [\n          {\n            name: 'preventOverflow',\n            enabled: true,\n            options: {\n              boundariesElement: 'viewport',\n              padding: 8, // viewport-margin for shifting/sliding\n            },\n          },\n          {\n            name: 'flip',\n            options: {\n              boundariesElement: 'viewport',\n              padding: 16, // viewport-margin for flipping\n            },\n          },\n          {\n            name: 'offset',\n            enabled: true,\n            options: {\n              offset: [0, 8], // horizontal and vertical margin (distance between popper and referenceElement)\n            },\n          },\n          {\n            name: 'arrow',\n            enabled: false,\n          },\n        ],\n      },\n      viewportConfig: {\n        placement: 'center',\n      },\n    };\n\n    this.manager.add(this);\n    /** @protected */\n    this._contentId = `overlay-content--${Math.random().toString(36).substr(2, 10)}`;\n    /** @private */\n    this.__originalAttrs = new Map();\n    if (this._defaultConfig.contentNode) {\n      if (!this._defaultConfig.contentNode.isConnected) {\n        throw new Error(\n          '[OverlayController] Could not find a render target, since the provided contentNode is not connected to the DOM. Make sure that it is connected, e.g. by doing \"document.body.appendChild(contentNode)\", before passing it on.',\n        );\n      }\n      this.__isContentNodeProjected = Boolean(this._defaultConfig.contentNode.assignedSlot);\n    }\n    this.updateConfig(config);\n    /** @private */\n    this.__hasActiveTrapsKeyboardFocus = false;\n    /** @private */\n    this.__hasActiveBackdrop = true;\n    /**\n     * @type {HTMLElement | undefined}\n     * @private\n     */\n    this.__backdropNodeToBeTornDown = undefined;\n\n    /** @private */\n    this.__escKeyHandler = this.__escKeyHandler.bind(this);\n  }\n\n  /**\n   * The invokerNode\n   * @type {HTMLElement | undefined}\n   */\n  get invoker() {\n    return this.invokerNode;\n  }\n\n  /**\n   * The contentWrapperNode\n   * @type {HTMLElement}\n   */\n  get content() {\n    return /** @type {HTMLElement} */ (this.contentWrapperNode);\n  }\n\n  /**\n   * Determines the connection point in DOM (body vs next to invoker).\n   * @type {'global' | 'local' | undefined}\n   */\n  get placementMode() {\n    return this.config?.placementMode;\n  }\n\n  /**\n   * The interactive element (usually a button) invoking the dialog or tooltip\n   * @type {HTMLElement | undefined}\n   */\n  get invokerNode() {\n    return this.config?.invokerNode;\n  }\n\n  /**\n   * The element that is used to position the overlay content relative to. Usually,\n   * this is the same element as invokerNode. Should only be provided when invokerNode should not\n   * be positioned against.\n   * @type {HTMLElement}\n   */\n  get referenceNode() {\n    return /** @type {HTMLElement} */ (this.config?.referenceNode);\n  }\n\n  /**\n   * The most important element: the overlay itself\n   * @type {HTMLElement}\n   */\n  get contentNode() {\n    return /** @type {HTMLElement} */ (this.config?.contentNode);\n  }\n\n  /**\n   * The wrapper element of contentNode, used to supply inline positioning styles. When a Popper\n   * arrow is needed, it acts as parent of the arrow node. Will be automatically created for global\n   * and non projected contentNodes. Required when used in shadow dom mode or when Popper arrow is\n   * supplied. Essential for allowing webcomponents to style their projected contentNodes\n   * @type {HTMLElement}\n   */\n  get contentWrapperNode() {\n    return /** @type {HTMLElement} */ (\n      this.__contentWrapperNode || this.config?.contentWrapperNode\n    );\n  }\n\n  /**\n   * The element that is placed behind the contentNode. When not provided and `hasBackdrop` is true,\n   * a backdropNode will be automatically created\n   * @type {HTMLElement}\n   */\n  get backdropNode() {\n    return /** @type {HTMLElement} */ (this.__backdropNode || this.config?.backdropNode);\n  }\n\n  /**\n   * The element that should be called `.focus()` on after dialog closes\n   * @type {HTMLElement}\n   */\n  get elementToFocusAfterHide() {\n    return /** @type {HTMLElement} */ (\n      this.__elementToFocusAfterHide || this.config?.elementToFocusAfterHide\n    );\n  }\n\n  /**\n   * Whether it should have a backdrop (currently exclusive to globalOverlayController)\n   * @type {boolean}\n   */\n  get hasBackdrop() {\n    return /** @type {boolean} */ (!!this.backdropNode || this.config?.hasBackdrop);\n  }\n\n  /**\n   * Hides other overlays when mutiple are opened (currently exclusive to globalOverlayController)\n   * @type {boolean}\n   */\n  get isBlocking() {\n    return /** @type {boolean} */ (this.config?.isBlocking);\n  }\n\n  /**\n   * Hides other overlays when mutiple are opened (currently exclusive to globalOverlayController)\n   * @type {boolean}\n   */\n  get preventsScroll() {\n    return /** @type {boolean} */ (this.config?.preventsScroll);\n  }\n\n  /**\n   * Rotates tab, implicitly set when 'isModal'\n   * @type {boolean}\n   */\n  get trapsKeyboardFocus() {\n    return /** @type {boolean} */ (this.config?.trapsKeyboardFocus);\n  }\n\n  /**\n   * Hides the overlay when pressing [ esc ]\n   * @type {boolean}\n   */\n  get hidesOnEsc() {\n    return /** @type {boolean} */ (this.config?.hidesOnEsc);\n  }\n\n  /**\n   * Hides the overlay when clicking next to it, exluding invoker\n   * @type {boolean}\n   */\n  get hidesOnOutsideClick() {\n    return /** @type {boolean} */ (this.config?.hidesOnOutsideClick);\n  }\n\n  /**\n   * Hides the overlay when pressing esc, even when contentNode has no focus\n   * @type {boolean}\n   */\n  get hidesOnOutsideEsc() {\n    return /** @type {boolean} */ (this.config?.hidesOnOutsideEsc);\n  }\n\n  /**\n   * Will align contentNode with referenceNode (invokerNode by default) for local overlays.\n   * Usually needed for dropdowns. 'max' will prevent contentNode from exceeding width of\n   * referenceNode, 'min' guarantees that contentNode will be at least as wide as referenceNode.\n   * 'full' will make sure that the invoker width always is the same.\n   * @type {'max' | 'full' | 'min' | 'none' | undefined }\n   */\n  get inheritsReferenceWidth() {\n    return this.config?.inheritsReferenceWidth;\n  }\n\n  /**\n   * For non `isTooltip`:\n   *  - sets aria-expanded=\"true/false\" and aria-haspopup=\"true\" on invokerNode\n   *  - sets aria-controls on invokerNode\n   *  - returns focus to invokerNode on hide\n   *  - sets focus to overlay content(?)\n   *\n   * For `isTooltip`:\n   *  - sets role=\"tooltip\" and aria-labelledby/aria-describedby on the content\n   *\n   * @type {boolean}\n   */\n  get handlesAccessibility() {\n    return /** @type {boolean} */ (this.config?.handlesAccessibility);\n  }\n\n  /**\n   * Has a totally different interaction- and accessibility pattern from all other overlays.\n   * Will behave as role=\"tooltip\" element instead of a role=\"dialog\" element\n   * @type {boolean}\n   */\n  get isTooltip() {\n    return /** @type {boolean} */ (this.config?.isTooltip);\n  }\n\n  /**\n   * By default, the tooltip content is a 'description' for the invoker (uses aria-describedby).\n   * Setting this property to 'label' makes the content function as a label (via aria-labelledby)\n   * @type {'label' | 'description'| undefined}\n   */\n  get invokerRelation() {\n    return this.config?.invokerRelation;\n  }\n\n  /**\n   * Popper configuration. Will be used when placementMode is 'local'\n   * @type {PopperOptions}\n   */\n  get popperConfig() {\n    return /** @type {PopperOptions} */ (this.config?.popperConfig);\n  }\n\n  /**\n   * Viewport configuration. Will be used when placementMode is 'global'\n   * @type {ViewportConfig}\n   */\n  get viewportConfig() {\n    return /** @type {ViewportConfig} */ (this.config?.viewportConfig);\n  }\n\n  /**\n   * Usually the parent node of contentWrapperNode that either exists locally or globally.\n   * When a responsive scenario is created (in which we switch from global to local or vice versa)\n   * we need to know where we should reappend contentWrapperNode (or contentNode in case it's\n   * projected).\n   * @type {HTMLElement}\n   * @protected\n   */\n  get _renderTarget() {\n    /** config [g1] */\n    if (this.placementMode === 'global') {\n      return this.manager.globalRootNode;\n    }\n    /** config [l2] or [l4] */\n    if (this.__isContentNodeProjected) {\n      // @ts-expect-error [external]: fix Node types\n      return this.__originalContentParent?.getRootNode().host;\n    }\n    /** config [l1] or [l3] */\n    return /** @type {HTMLElement} */ (this.__originalContentParent);\n  }\n\n  /**\n   * @desc The element our local overlay will be positioned relative to.\n   * @type {HTMLElement | undefined}\n   * @protected\n   */\n  get _referenceNode() {\n    return this.referenceNode || this.invokerNode;\n  }\n\n  /**\n   * @param {number} value\n   */\n  set elevation(value) {\n    if (this.contentWrapperNode) {\n      this.contentWrapperNode.style.zIndex = `${value}`;\n    }\n    if (this.backdropNode) {\n      this.backdropNode.style.zIndex = `${value}`;\n    }\n  }\n\n  /**\n   * @type {number}\n   */\n  get elevation() {\n    return Number(this.contentWrapperNode?.style.zIndex);\n  }\n\n  /**\n   * Allows to dynamically change the overlay configuration. Needed in case the\n   * presentation of the overlay changes depending on screen size.\n   * Note that this method is the only allowed way to update a configuration of an\n   * OverlayController instance.\n   * @param { OverlayConfig } cfgToAdd\n   */\n  updateConfig(cfgToAdd) {\n    // Teardown all previous configs\n    this.teardown();\n\n    /**\n     * @type {OverlayConfig}\n     * @private\n     */\n    this.__prevConfig = this.config || {};\n\n    /** @type {OverlayConfig} */\n    this.config = {\n      ...this._defaultConfig, // our basic ingredients\n      ...this.__sharedConfig, // the initial configured overlayController\n      ...cfgToAdd, // the added config\n      popperConfig: {\n        ...(this._defaultConfig.popperConfig || {}),\n        ...(this.__sharedConfig.popperConfig || {}),\n        ...(cfgToAdd.popperConfig || {}),\n        modifiers: [\n          ...((this._defaultConfig.popperConfig && this._defaultConfig.popperConfig.modifiers) ||\n            []),\n          ...((this.__sharedConfig.popperConfig && this.__sharedConfig.popperConfig.modifiers) ||\n            []),\n          ...((cfgToAdd.popperConfig && cfgToAdd.popperConfig.modifiers) || []),\n        ],\n      },\n    };\n\n    /** @private */\n    this.__validateConfiguration(/** @type {OverlayConfig} */ (this.config));\n    /** @protected */\n    this._init({ cfgToAdd });\n    /** @private */\n    this.__elementToFocusAfterHide = undefined;\n  }\n\n  /**\n   * @param {OverlayConfig} newConfig\n   * @private\n   */\n  // eslint-disable-next-line class-methods-use-this\n  __validateConfiguration(newConfig) {\n    if (!newConfig.placementMode) {\n      throw new Error(\n        '[OverlayController] You need to provide a .placementMode (\"global\"|\"local\")',\n      );\n    }\n    if (!['global', 'local'].includes(newConfig.placementMode)) {\n      throw new Error(\n        `[OverlayController] \"${newConfig.placementMode}\" is not a valid .placementMode, use (\"global\"|\"local\")`,\n      );\n    }\n    if (!newConfig.contentNode) {\n      throw new Error('[OverlayController] You need to provide a .contentNode');\n    }\n    if (this.__isContentNodeProjected && !newConfig.contentWrapperNode) {\n      throw new Error(\n        '[OverlayController] You need to provide a .contentWrapperNode when .contentNode is projected',\n      );\n    }\n    if (newConfig.isTooltip && newConfig.placementMode !== 'local') {\n      throw new Error(\n        '[OverlayController] .isTooltip should be configured with .placementMode \"local\"',\n      );\n    }\n    if (newConfig.isTooltip && !newConfig.handlesAccessibility) {\n      throw new Error(\n        '[OverlayController] .isTooltip only takes effect when .handlesAccessibility is enabled',\n      );\n    }\n    // if (newConfig.popperConfig.modifiers.arrow && !newConfig.contentWrapperNode) {\n    //   throw new Error('You need to provide a .contentWrapperNode when Popper arrow is enabled');\n    // }\n  }\n\n  /**\n   * @param {{ cfgToAdd: OverlayConfig }} options\n   * @protected\n   */\n  _init({ cfgToAdd }) {\n    this.__initContentWrapperNode({ cfgToAdd });\n    this.__initConnectionTarget();\n\n    if (this.placementMode === 'local') {\n      // Lazily load Popper if not done yet\n      if (!OverlayController.popperModule) {\n        // a@ts-expect-error FIXME: for some reason createPopper is missing here\n        OverlayController.popperModule = preloadPopper();\n      }\n    }\n    this._handleFeatures({ phase: 'init' });\n  }\n\n  /** @private */\n  __initConnectionTarget() {\n    // Now, add our node to the right place in dom (renderTarget)\n    if (this.contentWrapperNode !== this.__prevConfig?.contentWrapperNode) {\n      if (this.config?.placementMode === 'global' || !this.__isContentNodeProjected) {\n        /** @type {HTMLElement} */\n        (this.contentWrapperNode).appendChild(this.contentNode);\n      }\n    }\n\n    if (!this._renderTarget) {\n      return;\n    }\n\n    if (this.__isContentNodeProjected && this.placementMode === 'local') {\n      // We add the contentNode in its slot, so that it will be projected by contentWrapperNode\n      this._renderTarget.appendChild(this.contentNode);\n    } else {\n      const isInsideRenderTarget = this._renderTarget === this.contentWrapperNode.parentNode;\n      const nodeContainsTarget = this.contentWrapperNode.contains(this._renderTarget);\n      if (!isInsideRenderTarget && !nodeContainsTarget) {\n        // contentWrapperNode becomes the direct (non projected) parent of contentNode\n        this._renderTarget.appendChild(this.contentWrapperNode);\n      }\n    }\n  }\n\n  /**\n   * Cleanup ._contentWrapperNode. We do this, because creating a fresh wrapper\n   * can lead to problems with event listeners...\n   * @param {{ cfgToAdd: OverlayConfig }} options\n   * @private\n   */\n  __initContentWrapperNode({ cfgToAdd }) {\n    if (this.config?.contentWrapperNode && this.placementMode === 'local') {\n      /** config [l2],[l3],[l4] */\n      this.__contentWrapperNode = this.config.contentWrapperNode;\n    } else {\n      /** config [l1],[g1] */\n      this.__contentWrapperNode = document.createElement('div');\n    }\n\n    this.contentWrapperNode.style.cssText = '';\n    this.contentWrapperNode.style.display = 'none';\n\n    if (getComputedStyle(this.contentNode).position === 'absolute') {\n      // Having a _contWrapperNode and a contentNode with 'position:absolute' results in\n      // computed height of 0...\n      this.contentNode.style.position = 'static';\n    }\n\n    if (this.__isContentNodeProjected && this.contentWrapperNode.isConnected) {\n      // We need to keep track of the original local context.\n      /** config [l2], [l4] */\n      this.__originalContentParent = /** @type {HTMLElement} */ (\n        this.contentWrapperNode.parentNode\n      );\n    } else if (cfgToAdd.contentNode && cfgToAdd.contentNode.isConnected) {\n      // We need to keep track of the original local context.\n      /** config [l1], [l3], [g1] */\n      this.__originalContentParent = /** @type {HTMLElement} */ (this.contentNode?.parentNode);\n    }\n  }\n\n  /**\n   * Display local overlays on top of elements with no z-index that appear later in the DOM\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleZIndex({ phase }) {\n    if (this.placementMode !== 'local') {\n      return;\n    }\n\n    if (phase === 'setup') {\n      const zIndexNumber = Number(getComputedStyle(this.contentNode).zIndex);\n      if (zIndexNumber < 1 || Number.isNaN(zIndexNumber)) {\n        this.contentWrapperNode.style.zIndex = '1';\n      }\n    }\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @private\n   */\n  __setupTeardownAccessibility({ phase }) {\n    if (phase === 'init') {\n      this.__storeOriginalAttrs(this.contentNode, ['role', 'id']);\n\n      if (this.invokerNode) {\n        this.__storeOriginalAttrs(this.invokerNode, [\n          'aria-expanded',\n          'aria-labelledby',\n          'aria-describedby',\n        ]);\n      }\n\n      if (!this.contentNode.id) {\n        this.contentNode.setAttribute('id', this._contentId);\n      }\n      if (this.isTooltip) {\n        if (this.invokerNode) {\n          this.invokerNode.setAttribute(\n            this.invokerRelation === 'label' ? 'aria-labelledby' : 'aria-describedby',\n            this._contentId,\n          );\n        }\n        this.contentNode.setAttribute('role', 'tooltip');\n      } else {\n        if (this.invokerNode) {\n          this.invokerNode.setAttribute('aria-expanded', `${this.isShown}`);\n        }\n        if (!this.contentNode.getAttribute('role')) {\n          this.contentNode.setAttribute('role', 'dialog');\n        }\n      }\n    } else if (phase === 'teardown') {\n      this.__restoreOriginalAttrs();\n    }\n  }\n\n  /**\n   * @param {HTMLElement} node\n   * @param {string[]} attrs\n   * @private\n   */\n  __storeOriginalAttrs(node, attrs) {\n    const attrMap = {};\n    attrs.forEach(attrName => {\n      attrMap[attrName] = node.getAttribute(attrName);\n    });\n    this.__originalAttrs.set(node, attrMap);\n  }\n\n  /** @private */\n  __restoreOriginalAttrs() {\n    for (const [node, attrMap] of this.__originalAttrs) {\n      Object.entries(attrMap).forEach(([attrName, value]) => {\n        if (value !== null) {\n          node.setAttribute(attrName, value);\n        } else {\n          node.removeAttribute(attrName);\n        }\n      });\n    }\n    this.__originalAttrs.clear();\n  }\n\n  get isShown() {\n    return Boolean(this.contentWrapperNode.style.display !== 'none');\n  }\n\n  /**\n   * @event before-show right before the overlay shows. Used for animations and switching overlays\n   * @event show right after the overlay is shown\n   * @param {HTMLElement} elementToFocusAfterHide\n   */\n  async show(elementToFocusAfterHide = this.elementToFocusAfterHide) {\n    // Subsequent shows could happen, make sure we await it first.\n    // Otherwise it gets replaced before getting resolved, and places awaiting it will time out.\n    if (this._showComplete) {\n      await this._showComplete;\n    }\n    this._showComplete = new Promise(resolve => {\n      this._showResolve = resolve;\n    });\n\n    if (this.manager) {\n      this.manager.show(this);\n    }\n\n    if (this.isShown) {\n      /** @type {function} */\n      (this._showResolve)();\n      return;\n    }\n\n    const event = new CustomEvent('before-show', { cancelable: true });\n    this.dispatchEvent(event);\n    if (!event.defaultPrevented) {\n      this.contentWrapperNode.style.display = '';\n      this._keepBodySize({ phase: 'before-show' });\n      await this._handleFeatures({ phase: 'show' });\n      this._keepBodySize({ phase: 'show' });\n      await this._handlePosition({ phase: 'show' });\n      this.__elementToFocusAfterHide = elementToFocusAfterHide;\n      this.dispatchEvent(new Event('show'));\n      await this._transitionShow({\n        backdropNode: this.backdropNode,\n        contentNode: this.contentNode,\n      });\n    }\n    /** @type {function} */\n    (this._showResolve)();\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  async _handlePosition({ phase }) {\n    if (this.placementMode === 'global') {\n      const addOrRemove = phase === 'show' ? 'add' : 'remove';\n      const placementClass = `${GLOBAL_OVERLAYS_CONTAINER_CLASS}--${this.viewportConfig.placement}`;\n      this.contentWrapperNode.classList[addOrRemove](GLOBAL_OVERLAYS_CONTAINER_CLASS);\n      this.contentWrapperNode.classList[addOrRemove](placementClass);\n      this.contentNode.classList[addOrRemove](GLOBAL_OVERLAYS_CLASS);\n    } else if (this.placementMode === 'local' && phase === 'show') {\n      /**\n       * Popper is weird about properly positioning the popper element when it is recreated so\n       * we just recreate the popper instance to make it behave like it should.\n       * Probably related to this issue: https://github.com/FezVrasta/popper.js/issues/796\n       * calling just the .update() function on the popper instance sadly does not resolve this.\n       * This is however necessary for initial placement.\n       */\n      await this.__createPopperInstance();\n      /** @type {Popper} */ (this._popper).forceUpdate();\n    }\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _keepBodySize({ phase }) {\n    switch (phase) {\n      case 'before-show':\n        this.__bodyClientWidth = document.body.clientWidth;\n        this.__bodyClientHeight = document.body.clientHeight;\n        this.__bodyMarginRightInline = document.body.style.marginRight;\n        this.__bodyMarginBottomInline = document.body.style.marginBottom;\n        break;\n      case 'show': {\n        if (window.getComputedStyle) {\n          const bodyStyle = window.getComputedStyle(document.body);\n          this.__bodyMarginRight = parseInt(bodyStyle.getPropertyValue('margin-right'), 10);\n          this.__bodyMarginBottom = parseInt(bodyStyle.getPropertyValue('margin-bottom'), 10);\n        } else {\n          this.__bodyMarginRight = 0;\n          this.__bodyMarginBottom = 0;\n        }\n        const scrollbarWidth =\n          document.body.clientWidth - /** @type {number} */ (this.__bodyClientWidth);\n        const scrollbarHeight =\n          document.body.clientHeight - /** @type {number} */ (this.__bodyClientHeight);\n        const newMarginRight = this.__bodyMarginRight + scrollbarWidth;\n        const newMarginBottom = this.__bodyMarginBottom + scrollbarHeight;\n        if (supportsCSSTypedObject) {\n          // @ts-expect-error [external]: types attributeStyleMap + CSS.px not available yet\n          document.body.attributeStyleMap.set('margin-right', CSS.px(newMarginRight));\n          // @ts-expect-error [external]: types attributeStyleMap + CSS.px not available yet\n          document.body.attributeStyleMap.set('margin-bottom', CSS.px(newMarginBottom));\n        } else {\n          document.body.style.marginRight = `${newMarginRight}px`;\n          document.body.style.marginBottom = `${newMarginBottom}px`;\n        }\n        break;\n      }\n      case 'hide':\n        document.body.style.marginRight = this.__bodyMarginRightInline || '';\n        document.body.style.marginBottom = this.__bodyMarginBottomInline || '';\n        break;\n      /* no default */\n    }\n  }\n\n  /**\n   * @event before-hide right before the overlay hides. Used for animations and switching overlays\n   * @event hide right after the overlay is hidden\n   */\n  async hide() {\n    this._hideComplete = new Promise(resolve => {\n      this._hideResolve = resolve;\n    });\n\n    if (this.manager) {\n      this.manager.hide(this);\n    }\n\n    if (!this.isShown) {\n      /** @type {function} */ (this._hideResolve)();\n      return;\n    }\n\n    const event = new CustomEvent('before-hide', { cancelable: true });\n    this.dispatchEvent(event);\n    if (!event.defaultPrevented) {\n      await this._transitionHide({\n        backdropNode: this.backdropNode,\n        contentNode: this.contentNode,\n      });\n\n      this.contentWrapperNode.style.display = 'none';\n      this._handleFeatures({ phase: 'hide' });\n      this._keepBodySize({ phase: 'hide' });\n      this.dispatchEvent(new Event('hide'));\n      this._restoreFocus();\n    }\n    /** @type {function} */ (this._hideResolve)();\n  }\n\n  /**\n   * Method to be overriden by subclassers\n   *\n   * @param {{backdropNode:HTMLElement, contentNode:HTMLElement}} hideConfig\n   */\n  // eslint-disable-next-line class-methods-use-this, no-empty-function, no-unused-vars\n  async transitionHide(hideConfig) {}\n\n  /**\n   * @param {{backdropNode:HTMLElement, contentNode:HTMLElement}} hideConfig\n   * @protected\n   */\n  // eslint-disable-next-line class-methods-use-this, no-empty-function, no-unused-vars\n  async _transitionHide(hideConfig) {\n    // `this.transitionHide` is a hook for our users\n    await this.transitionHide({ backdropNode: this.backdropNode, contentNode: this.contentNode });\n\n    if (hideConfig.backdropNode) {\n      hideConfig.backdropNode.classList.remove(\n        `${this.placementMode}-overlays__backdrop--animation-in`,\n      );\n      /** @type {() => void} */\n      let afterFadeOut = () => {};\n      hideConfig.backdropNode.classList.add(\n        `${this.placementMode}-overlays__backdrop--animation-out`,\n      );\n      this.__backdropAnimation = new Promise(resolve => {\n        afterFadeOut = () => {\n          if (hideConfig.backdropNode) {\n            hideConfig.backdropNode.classList.remove(\n              `${this.placementMode}-overlays__backdrop--animation-out`,\n            );\n            hideConfig.backdropNode.classList.remove(\n              `${this.placementMode}-overlays__backdrop--visible`,\n            );\n            hideConfig.backdropNode.removeEventListener('animationend', afterFadeOut);\n          }\n          resolve(undefined);\n        };\n      });\n\n      hideConfig.backdropNode.addEventListener('animationend', afterFadeOut);\n    }\n  }\n\n  /**\n   * To be overridden by subclassers\n   *\n   * @param {{backdropNode:HTMLElement, contentNode:HTMLElement}} showConfig\n   */\n  // eslint-disable-next-line class-methods-use-this, no-empty-function, no-unused-vars\n  async transitionShow(showConfig) {}\n\n  /**\n   * @param {{backdropNode:HTMLElement, contentNode:HTMLElement}} showConfig\n   */\n  // eslint-disable-next-line class-methods-use-this, no-empty-function, no-unused-vars\n  async _transitionShow(showConfig) {\n    // `this.transitionShow` is a hook for our users\n    await this.transitionShow({ backdropNode: this.backdropNode, contentNode: this.contentNode });\n\n    if (showConfig.backdropNode) {\n      showConfig.backdropNode.classList.add(\n        `${this.placementMode}-overlays__backdrop--animation-in`,\n      );\n    }\n  }\n\n  /** @protected */\n  _restoreFocus() {\n    const { activeElement } = /** @type {* & ShadowRoot} */ (\n      this.__contentWrapperNode\n    ).getRootNode();\n    // We only are allowed to move focus if we (still) 'own' it.\n    // Otherwise we assume the 'outside world' has, purposefully, taken over\n    if (\n      activeElement &&\n      /** @type {HTMLElement} */ (this.__contentWrapperNode).contains(activeElement)\n    ) {\n      if (this.elementToFocusAfterHide) {\n        this.elementToFocusAfterHide.focus();\n      } else {\n        activeElement.blur();\n      }\n    }\n  }\n\n  async toggle() {\n    return this.isShown ? this.hide() : this.show();\n  }\n\n  /**\n   * All features are handled here.\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleFeatures({ phase }) {\n    this._handleZIndex({ phase });\n\n    if (this.preventsScroll) {\n      this._handlePreventsScroll({ phase });\n    }\n    if (this.isBlocking) {\n      this._handleBlocking({ phase });\n    }\n    if (this.hasBackdrop) {\n      this._handleBackdrop({ phase });\n    }\n    if (this.trapsKeyboardFocus) {\n      this._handleTrapsKeyboardFocus({ phase });\n    }\n    if (this.hidesOnEsc) {\n      this._handleHidesOnEsc({ phase });\n    }\n    if (this.hidesOnOutsideEsc) {\n      this._handleHidesOnOutsideEsc({ phase });\n    }\n    if (this.hidesOnOutsideClick) {\n      this._handleHidesOnOutsideClick({ phase });\n    }\n    if (this.handlesAccessibility) {\n      this._handleAccessibility({ phase });\n    }\n    if (this.inheritsReferenceWidth) {\n      this._handleInheritsReferenceWidth();\n    }\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handlePreventsScroll({ phase }) {\n    switch (phase) {\n      case 'show':\n        this.manager.requestToPreventScroll();\n        break;\n      case 'hide':\n        this.manager.requestToEnableScroll();\n        break;\n      /* no default */\n    }\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleBlocking({ phase }) {\n    switch (phase) {\n      case 'show':\n        this.manager.requestToShowOnly(this);\n        break;\n      case 'hide':\n        this.manager.retractRequestToShowOnly(this);\n        break;\n      /* no default */\n    }\n  }\n\n  get hasActiveBackdrop() {\n    return this.__hasActiveBackdrop;\n  }\n\n  /**\n   * Sets up backdrop on the given overlay. If there was a backdrop on another element\n   * it is removed. Otherwise this is the first time displaying a backdrop, so a animation-in\n   * animation is played.\n   * @param {{ animation?: boolean, phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleBackdrop({ phase }) {\n    switch (phase) {\n      case 'init': {\n        if (!this.backdropNode) {\n          this.__backdropNode = document.createElement('div');\n          /** @type {HTMLElement} */\n          (this.backdropNode).slot = 'backdrop';\n          /** @type {HTMLElement} */\n          (this.backdropNode).classList.add(`${this.placementMode}-overlays__backdrop`);\n        }\n\n        let insertionAnchor = /** @type {HTMLElement} */ (this.contentNode.parentNode);\n        let insertionBefore = this.contentNode;\n        if (this.placementMode === 'global') {\n          insertionAnchor = /** @type {HTMLElement} */ (this.contentWrapperNode.parentElement);\n          insertionBefore = this.contentWrapperNode;\n        }\n        insertionAnchor.insertBefore(this.backdropNode, insertionBefore);\n        break;\n      }\n      case 'show':\n        this.backdropNode.classList.add(`${this.placementMode}-overlays__backdrop--visible`);\n        this.__hasActiveBackdrop = true;\n        break;\n      case 'hide':\n        if (!this.backdropNode) {\n          return;\n        }\n        this.__hasActiveBackdrop = false;\n        break;\n      case 'teardown':\n        if (!this.backdropNode || !this.backdropNode.parentNode) {\n          return;\n        }\n        if (this.__backdropAnimation) {\n          this.__backdropNodeToBeTornDown = this.backdropNode;\n\n          this.__backdropAnimation.then(() => {\n            if (this.__backdropNodeToBeTornDown && this.__backdropNodeToBeTornDown.parentNode) {\n              this.__backdropNodeToBeTornDown.parentNode.removeChild(\n                this.__backdropNodeToBeTornDown,\n              );\n            }\n          });\n        } else {\n          this.backdropNode.parentNode.removeChild(this.backdropNode);\n        }\n        this.__backdropNode = undefined;\n        break;\n      /* no default */\n    }\n  }\n\n  get hasActiveTrapsKeyboardFocus() {\n    return this.__hasActiveTrapsKeyboardFocus;\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleTrapsKeyboardFocus({ phase }) {\n    if (phase === 'show') {\n      this.enableTrapsKeyboardFocus();\n    } else if (phase === 'hide' || phase === 'teardown') {\n      this.disableTrapsKeyboardFocus();\n    }\n  }\n\n  enableTrapsKeyboardFocus() {\n    if (this.__hasActiveTrapsKeyboardFocus) {\n      return;\n    }\n    if (this.manager) {\n      this.manager.disableTrapsKeyboardFocusForAll();\n    }\n    this._containFocusHandler = containFocus(this.contentNode);\n    this.__hasActiveTrapsKeyboardFocus = true;\n    if (this.manager) {\n      this.manager.informTrapsKeyboardFocusGotEnabled(this.placementMode);\n    }\n  }\n\n  disableTrapsKeyboardFocus({ findNewTrap = true } = {}) {\n    if (!this.__hasActiveTrapsKeyboardFocus) {\n      return;\n    }\n    if (this._containFocusHandler) {\n      this._containFocusHandler.disconnect();\n      this._containFocusHandler = undefined;\n    }\n    this.__hasActiveTrapsKeyboardFocus = false;\n    if (this.manager) {\n      this.manager.informTrapsKeyboardFocusGotDisabled({ disabledCtrl: this, findNewTrap });\n    }\n  }\n\n  /** @private */\n  __escKeyHandler(/** @type {KeyboardEvent} */ ev) {\n    return ev.key === 'Escape' && this.hide();\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleHidesOnEsc({ phase }) {\n    if (phase === 'show') {\n      this.contentNode.addEventListener('keyup', this.__escKeyHandler);\n      if (this.invokerNode) {\n        this.invokerNode.addEventListener('keyup', this.__escKeyHandler);\n      }\n    } else if (phase === 'hide') {\n      this.contentNode.removeEventListener('keyup', this.__escKeyHandler);\n      if (this.invokerNode) {\n        this.invokerNode.removeEventListener('keyup', this.__escKeyHandler);\n      }\n    }\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleHidesOnOutsideEsc({ phase }) {\n    if (phase === 'show') {\n      this.__escKeyHandler = (/** @type {KeyboardEvent} */ ev) =>\n        ev.key === 'Escape' && this.hide();\n      document.addEventListener('keyup', this.__escKeyHandler);\n    } else if (phase === 'hide') {\n      document.removeEventListener('keyup', this.__escKeyHandler);\n    }\n  }\n\n  /** @protected */\n  _handleInheritsReferenceWidth() {\n    if (!this._referenceNode || this.placementMode === 'global') {\n      return;\n    }\n    const referenceWidth = `${this._referenceNode.getBoundingClientRect().width}px`;\n    switch (this.inheritsReferenceWidth) {\n      case 'max':\n        this.contentWrapperNode.style.maxWidth = referenceWidth;\n        break;\n      case 'full':\n        this.contentWrapperNode.style.width = referenceWidth;\n        break;\n      case 'min':\n        this.contentWrapperNode.style.minWidth = referenceWidth;\n        this.contentWrapperNode.style.width = 'auto';\n        break;\n      /* no default */\n    }\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleHidesOnOutsideClick({ phase }) {\n    const addOrRemoveListener = phase === 'show' ? 'addEventListener' : 'removeEventListener';\n\n    if (phase === 'show') {\n      /**\n       * We listen to click (more specifically mouseup and mousedown) events\n       * in their capture phase (see our tests about 3rd parties stopping event propagation).\n       * We define an outside click as follows:\n       * - both mousedown and mouseup occur outside of content or invoker\n       *\n       * This means we have the following flow:\n       * [1]. (optional) mousedown is triggered on content/invoker\n       * [2]. mouseup is triggered on document (logic will be scheduled to step 4)\n       * [3]. (optional) mouseup is triggered on content/invoker\n       * [4]. mouseup logic is executed on document (its logic is inside a timeout and is thus\n       * executed after 3)\n       * [5]. Reset all helper variables that were considered in step [4]\n       *\n       */\n\n      /** @type {boolean} */\n      let wasMouseDownInside = false;\n      /** @type {boolean} */\n      let wasMouseUpInside = false;\n\n      /** @type {EventListenerOrEventListenerObject} */\n      this.__onInsideMouseDown = () => {\n        // [1]. was mousedown inside content or invoker\n        wasMouseDownInside = true;\n      };\n\n      this.__onInsideMouseUp = () => {\n        // [3]. was mouseup inside content or invoker\n        wasMouseUpInside = true;\n      };\n\n      /** @type {EventListenerOrEventListenerObject} */\n      this.__onDocumentMouseUp = () => {\n        // [2]. The captured mouseup goes from top of the document to bottom. We add a timeout,\n        // so that [3] can be executed before [4]\n        setTimeout(() => {\n          // [4]. Keep open if step 1 (mousedown) or 3 (mouseup) was inside\n          if (!wasMouseDownInside && !wasMouseUpInside) {\n            this.hide();\n          }\n          // [5]. Reset...\n          wasMouseDownInside = false;\n          wasMouseUpInside = false;\n        });\n      };\n    }\n\n    this.contentWrapperNode[addOrRemoveListener](\n      'mousedown',\n      /** @type {EventListenerOrEventListenerObject} */\n      (this.__onInsideMouseDown),\n      true,\n    );\n    this.contentWrapperNode[addOrRemoveListener](\n      'mouseup',\n      /** @type {EventListenerOrEventListenerObject} */\n      (this.__onInsideMouseUp),\n      true,\n    );\n    if (this.invokerNode) {\n      // An invoker click (usually resulting in toggle) should be left to a different part of\n      // the code\n      this.invokerNode[addOrRemoveListener](\n        'mousedown',\n        /** @type {EventListenerOrEventListenerObject} */\n        (this.__onInsideMouseDown),\n        true,\n      );\n      this.invokerNode[addOrRemoveListener](\n        'mouseup',\n        /** @type {EventListenerOrEventListenerObject} */\n        (this.__onInsideMouseUp),\n        true,\n      );\n    }\n    document.documentElement[addOrRemoveListener](\n      'mouseup',\n      /** @type {EventListenerOrEventListenerObject} */\n      (this.__onDocumentMouseUp),\n      true,\n    );\n  }\n\n  /**\n   * @param {{ phase: OverlayPhase }} config\n   * @protected\n   */\n  _handleAccessibility({ phase }) {\n    if (phase === 'init' || phase === 'teardown') {\n      this.__setupTeardownAccessibility({ phase });\n    }\n    if (this.invokerNode && !this.isTooltip) {\n      this.invokerNode.setAttribute('aria-expanded', `${phase === 'show'}`);\n    }\n  }\n\n  teardown() {\n    this._handleFeatures({ phase: 'teardown' });\n\n    if (this.placementMode === 'global' && this.__isContentNodeProjected) {\n      /** @type {HTMLElement} */ (this.__originalContentParent).appendChild(this.contentNode);\n    }\n\n    // Remove the content node wrapper from the global rootnode\n    this._teardownContentWrapperNode();\n  }\n\n  /** @protected */\n  _teardownContentWrapperNode() {\n    if (\n      this.placementMode === 'global' &&\n      this.contentWrapperNode &&\n      this.contentWrapperNode.parentNode\n    ) {\n      this.contentWrapperNode.parentNode.removeChild(this.contentWrapperNode);\n    }\n  }\n\n  /** @private */\n  async __createPopperInstance() {\n    if (this._popper) {\n      this._popper.destroy();\n      this._popper = undefined;\n    }\n\n    if (OverlayController.popperModule !== undefined) {\n      const { createPopper } = await OverlayController.popperModule;\n      this._popper = createPopper(this._referenceNode, this.contentWrapperNode, {\n        ...this.config?.popperConfig,\n      });\n    }\n  }\n}\n/** @type {Promise<PopperModule> | undefined} */\nOverlayController.popperModule = undefined;\n", "/**\n * @typedef {import('../../types/OverlayConfig').OverlayConfig} OverlayConfig\n */\n\n/**\n * Compares two OverlayConfigs to equivalence. Intended to prevent unnecessary resets.\n * Note that it doesn't cover as many use cases as common implementations, such as Lodash isEqual.\n *\n * @param {Partial<OverlayConfig>} a\n * @param {Partial<OverlayConfig>} b\n * @returns {boolean} Whether the configs are equivalent\n */\nexport function isEqualConfig(a, b) {\n  if (typeof a !== 'object' || typeof b !== 'object' || a === null || b === null) {\n    return a === b;\n  }\n  const aProps = Object.keys(a);\n  const bProps = Object.keys(b);\n  if (aProps.length !== bProps.length) {\n    return false;\n  }\n  const isEqual = /** @param {string} prop */ prop => isEqualConfig(a[prop], b[prop]);\n  return aProps.every(isEqual);\n}\n", "import { dedupeMixin } from '@lion/core';\nimport { OverlayController } from './OverlayController.js';\nimport { isEqualConfig } from './utils/is-equal-config.js';\n\n/**\n * @typedef {import('../types/OverlayConfig').OverlayConfig} OverlayConfig\n * @typedef {import('../types/OverlayMixinTypes').DefineOverlayConfig} DefineOverlayConfig\n * @typedef {import('../types/OverlayMixinTypes').OverlayMixin} OverlayMixin\n */\n\n/**\n * @type {OverlayMixin}\n * @param {import('@open-wc/dedupe-mixin').Constructor<import('@lion/core').LitElement>} superclass\n */\nexport const OverlayMixinImplementation = superclass =>\n  // @ts-ignore https://github.com/microsoft/TypeScript/issues/36821#issuecomment-588375051\n  class OverlayMixin extends superclass {\n    static get properties() {\n      return {\n        opened: {\n          type: Boolean,\n          reflect: true,\n        },\n      };\n    }\n\n    constructor() {\n      super();\n      this.opened = false;\n      /** @private */\n      this.__needsSetup = true;\n      /** @type {OverlayConfig} */\n      this.config = {};\n\n      /** @type {EventListener} */\n      this.toggle = this.toggle.bind(this);\n      /** @type {EventListener} */\n      this.open = this.open.bind(this);\n      /** @type {EventListener} */\n      this.close = this.close.bind(this);\n    }\n\n    get config() {\n      return /** @type {OverlayConfig} */ (this.__config);\n    }\n\n    /** @param {OverlayConfig} value */\n    set config(value) {\n      const shouldUpdate = !isEqualConfig(this.config, value);\n\n      if (this._overlayCtrl && shouldUpdate) {\n        this._overlayCtrl.updateConfig(value);\n      }\n      this.__config = value;\n      if (this._overlayCtrl && shouldUpdate) {\n        this.__syncToOverlayController();\n      }\n    }\n\n    /**\n     * @override\n     * @param {string} name\n     * @param {any} oldValue\n     */\n    requestUpdate(name, oldValue) {\n      super.requestUpdate(name, oldValue);\n      if (name === 'opened' && this.opened !== oldValue) {\n        this.dispatchEvent(new Event('opened-changed'));\n      }\n    }\n\n    /**\n     * @overridable method `_defineOverlay`\n     * @desc returns an instance of a (dynamic) overlay controller\n     * In case overriding _defineOverlayConfig is not enough\n     * @param {DefineOverlayConfig} config\n     * @returns {OverlayController}\n     * @protected\n     */\n    // eslint-disable-next-line\n    _defineOverlay({ contentNode, invokerNode, referenceNode, backdropNode, contentWrapperNode }) {\n      const overlayConfig = this._defineOverlayConfig() || {};\n      return new OverlayController({\n        contentNode,\n        invokerNode,\n        referenceNode,\n        backdropNode,\n        contentWrapperNode,\n        ...overlayConfig, // wc provided in the class as defaults\n        ...this.config, // user provided (e.g. in template)\n        popperConfig: {\n          ...(overlayConfig.popperConfig || {}),\n          ...(this.config.popperConfig || {}),\n          modifiers: [\n            ...(overlayConfig.popperConfig?.modifiers || []),\n            ...(this.config.popperConfig?.modifiers || []),\n          ],\n        },\n      });\n    }\n\n    /**\n     * @overridable method `_defineOverlayConfig`\n     * @desc returns an object with default configuration options for your overlay component.\n     * This is generally speaking easier to override than _defineOverlay method entirely.\n     * @returns {OverlayConfig}\n     * @protected\n     */\n    // eslint-disable-next-line\n    _defineOverlayConfig() {\n      return {\n        placementMode: 'local',\n      };\n    }\n\n    /**\n     * @param {import('@lion/core').PropertyValues } changedProperties\n     */\n    updated(changedProperties) {\n      super.updated(changedProperties);\n\n      if (changedProperties.has('opened') && this._overlayCtrl && !this.__blockSyncToOverlayCtrl) {\n        this.__syncToOverlayController();\n      }\n    }\n\n    /**\n     * @overridable\n     * @desc use this method to setup your open and close event listeners\n     * For example, set a click event listener on _overlayInvokerNode to set opened to true\n     * @protected\n     */\n    // eslint-disable-next-line class-methods-use-this\n    _setupOpenCloseListeners() {\n      /**\n       * @param {{ stopPropagation: () => void; }} ev\n       */\n      this.__closeEventInContentNodeHandler = ev => {\n        ev.stopPropagation();\n        /** @type {OverlayController} */ (this._overlayCtrl).hide();\n      };\n      if (this._overlayContentNode) {\n        this._overlayContentNode.addEventListener(\n          'close-overlay',\n          this.__closeEventInContentNodeHandler,\n        );\n      }\n    }\n\n    /**\n     * @overridable\n     * @desc use this method to tear down your event listeners\n     * @protected\n     */\n    // eslint-disable-next-line class-methods-use-this\n    _teardownOpenCloseListeners() {\n      if (this._overlayContentNode) {\n        this._overlayContentNode.removeEventListener(\n          'close-overlay',\n          /** @type {EventListener} */ (this.__closeEventInContentNodeHandler),\n        );\n      }\n    }\n\n    connectedCallback() {\n      super.connectedCallback();\n      // we do a setup after every connectedCallback as firstUpdated will only be called once\n      this.__needsSetup = true;\n      this.updateComplete.then(() => {\n        if (this.__needsSetup) {\n          this._setupOverlayCtrl();\n        }\n        this.__needsSetup = false;\n      });\n    }\n\n    disconnectedCallback() {\n      super.disconnectedCallback();\n      if (this._overlayCtrl) {\n        this._teardownOverlayCtrl();\n      }\n    }\n\n    get _overlayInvokerNode() {\n      return /** @type {HTMLElement | undefined} */ (\n        Array.from(this.children).find(child => child.slot === 'invoker')\n      );\n    }\n\n    /**\n     * @overridable\n     */\n    // eslint-disable-next-line class-methods-use-this\n    get _overlayReferenceNode() {\n      return undefined;\n    }\n\n    get _overlayBackdropNode() {\n      return /** @type {HTMLElement | undefined} */ (\n        Array.from(this.children).find(child => child.slot === 'backdrop')\n      );\n    }\n\n    get _overlayContentNode() {\n      if (!this._cachedOverlayContentNode) {\n        this._cachedOverlayContentNode =\n          Array.from(this.children).find(child => child.slot === 'content') ||\n          this.config.contentNode;\n      }\n      return /** @type {HTMLElement} */ (this._cachedOverlayContentNode);\n    }\n\n    get _overlayContentWrapperNode() {\n      return /** @type {HTMLElement | undefined} */ (\n        this.shadowRoot?.querySelector('#overlay-content-node-wrapper')\n      );\n    }\n\n    /** @protected */\n    _setupOverlayCtrl() {\n      /** @type {OverlayController} */\n      this._overlayCtrl = this._defineOverlay({\n        contentNode: this._overlayContentNode,\n        contentWrapperNode: this._overlayContentWrapperNode,\n        invokerNode: this._overlayInvokerNode,\n        referenceNode: this._overlayReferenceNode,\n        backdropNode: this._overlayBackdropNode,\n      });\n      this.__syncToOverlayController();\n      this.__setupSyncFromOverlayController();\n      this._setupOpenCloseListeners();\n    }\n\n    /** @protected */\n    _teardownOverlayCtrl() {\n      this._teardownOpenCloseListeners();\n      this.__teardownSyncFromOverlayController();\n      /** @type {OverlayController} */\n      (this._overlayCtrl).teardown();\n    }\n\n    /**\n     * When the opened state is changed by an Application Developer,cthe OverlayController is\n     * requested to show/hide. It might happen that this request is not honoured\n     * (intercepted in before-hide for instance), so that we need to sync the controller state\n     * to this webcomponent again, preventing eternal loops.\n     * @param {boolean} newOpened\n     * @protected\n     */\n    async _setOpenedWithoutPropertyEffects(newOpened) {\n      this.__blockSyncToOverlayCtrl = true;\n      this.opened = newOpened;\n      await this.updateComplete;\n      this.__blockSyncToOverlayCtrl = false;\n    }\n\n    /** @private */\n    __setupSyncFromOverlayController() {\n      this.__onOverlayCtrlShow = () => {\n        this.opened = true;\n      };\n\n      this.__onOverlayCtrlHide = () => {\n        this.opened = false;\n      };\n\n      /**\n       * @param {{ preventDefault: () => void; }} beforeShowEvent\n       */\n      this.__onBeforeShow = beforeShowEvent => {\n        const event = new CustomEvent('before-opened', { cancelable: true });\n        this.dispatchEvent(event);\n        if (event.defaultPrevented) {\n          // Check whether our current `.opened` state is not out of sync with overlayCtrl\n          this._setOpenedWithoutPropertyEffects(\n            /** @type {OverlayController} */ (this._overlayCtrl).isShown,\n          );\n          beforeShowEvent.preventDefault();\n        }\n      };\n\n      /**\n       * @param {{ preventDefault: () => void; }} beforeHideEvent\n       */\n      this.__onBeforeHide = beforeHideEvent => {\n        const event = new CustomEvent('before-closed', { cancelable: true });\n        this.dispatchEvent(event);\n        if (event.defaultPrevented) {\n          // Check whether our current `.opened` state is not out of sync with overlayCtrl\n          this._setOpenedWithoutPropertyEffects(\n            /** @type {OverlayController} */\n            (this._overlayCtrl).isShown,\n          );\n          beforeHideEvent.preventDefault();\n        }\n      };\n\n      /** @type {OverlayController} */\n      (this._overlayCtrl).addEventListener('show', this.__onOverlayCtrlShow);\n      /** @type {OverlayController} */\n      (this._overlayCtrl).addEventListener('hide', this.__onOverlayCtrlHide);\n      /** @type {OverlayController} */\n      (this._overlayCtrl).addEventListener('before-show', this.__onBeforeShow);\n      /** @type {OverlayController} */\n      (this._overlayCtrl).addEventListener('before-hide', this.__onBeforeHide);\n    }\n\n    /** @private */\n    __teardownSyncFromOverlayController() {\n      /** @type {OverlayController} */\n      (this._overlayCtrl).removeEventListener(\n        'show',\n        /** @type {EventListener} */ (this.__onOverlayCtrlShow),\n      );\n      /** @type {OverlayController} */ (this._overlayCtrl).removeEventListener(\n        'hide',\n        /** @type {EventListener} */ (this.__onOverlayCtrlHide),\n      );\n      /** @type {OverlayController} */ (this._overlayCtrl).removeEventListener(\n        'before-show',\n        /** @type {EventListener} */ (this.__onBeforeShow),\n      );\n      /** @type {OverlayController} */ (this._overlayCtrl).removeEventListener(\n        'before-hide',\n        /** @type {EventListener} */ (this.__onBeforeHide),\n      );\n    }\n\n    /** @private */\n    __syncToOverlayController() {\n      if (this.opened) {\n        /** @type {OverlayController} */\n        (this._overlayCtrl).show();\n      } else {\n        /** @type {OverlayController} */\n        (this._overlayCtrl).hide();\n      }\n    }\n\n    /**\n     * Toggles the overlay\n     */\n    async toggle() {\n      await /** @type {OverlayController} */ (this._overlayCtrl).toggle();\n    }\n\n    /**\n     * Shows the overlay\n     */\n    async open() {\n      await /** @type {OverlayController} */ (this._overlayCtrl).show();\n    }\n\n    /**\n     * Hides the overlay\n     */\n    async close() {\n      await /** @type {OverlayController} */ (this._overlayCtrl).hide();\n    }\n\n    /**\n     * Sometimes it's needed to recompute Popper position of an overlay, for instance when we have\n     * an opened combobox and the surrounding context changes (the space consumed by the textbox\n     * increases vertically)\n     */\n    repositionOverlay() {\n      const ctrl = /** @type {OverlayController} */ (this._overlayCtrl);\n      if (ctrl.placementMode === 'local' && ctrl._popper) {\n        ctrl._popper.update();\n      }\n    }\n  };\nexport const OverlayMixin = dedupeMixin(OverlayMixinImplementation);\n", "/**\n * @typedef {import('../../types/OverlayConfig').OverlayConfig} OverlayConfig\n */\n\nexport const withModalDialogConfig = () =>\n  /** @type {OverlayConfig} */ ({\n    placementMode: 'global',\n    viewportConfig: {\n      placement: 'center',\n    },\n    hasBackdrop: true,\n    preventsScroll: true,\n    trapsKeyboardFocus: true,\n    hidesOnEsc: true,\n    handlesAccessibility: true,\n  });\n", "import { html, LitElement } from '@lion/core';\nimport { OverlayMixin, withModalDialogConfig } from '@lion/overlays';\n\nexport class LionDialog extends OverlayMixin(LitElement) {\n  constructor() {\n    super();\n    /** @private */\n    this.__toggle = () => {\n      this.opened = !this.opened;\n    };\n  }\n\n  /**\n   * @protected\n   */\n  // eslint-disable-next-line class-methods-use-this\n  _defineOverlayConfig() {\n    return {\n      ...withModalDialogConfig(),\n    };\n  }\n\n  /**\n   * @protected\n   */\n  _setupOpenCloseListeners() {\n    super._setupOpenCloseListeners();\n    if (this._overlayInvokerNode) {\n      this._overlayInvokerNode.addEventListener('click', this.__toggle);\n    }\n  }\n\n  /**\n   * @protected\n   */\n  _teardownOpenCloseListeners() {\n    super._teardownOpenCloseListeners();\n    if (this._overlayInvokerNode) {\n      this._overlayInvokerNode.removeEventListener('click', this.__toggle);\n    }\n  }\n\n  render() {\n    return html`\n      <slot name=\"invoker\"></slot>\n      <div id=\"overlay-content-node-wrapper\">\n        <slot name=\"content\"></slot>\n      </div>\n    `;\n  }\n}\n", "import { LionDialog } from './src/LionDialog.js';\n\ncustomElements.define('lion-dialog', LionDialog);\n"],
  "mappings": "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",
  "names": ["globalOverlaysStyle", "i", "setSiblingsInert", "element", "parentChildren", "i", "sibling", "unsetSiblingsInert", "isIOS", "OverlaysManager", "_OverlaysManager", "rootNode", "styleTag", "globalOverlaysStyle", "ctrlToAdd", "ctrl", "ctrlToRemove", "ctrlToShow", "ctrlToHide", "placementMode", "setSiblingsInert", "disabledCtrl", "findNewTrap", "next", "unsetSiblingsInert", "blockingCtrl", "controllersToHide", "overlays", "singletonManager", "OverlaysManager", "getDeepActiveElement", "host", "hasStyleVisibility", "visibility", "display", "isDisplayContents", "isVisible", "element", "computedStyle", "hasLowerTabOrder", "a", "b", "ati", "bti", "mergeSortByTabIndex", "left", "right", "result", "sortByTabIndex", "elements", "len", "pivot", "matchesFunc", "isFocusable", "element", "getTabindex", "getChildNodes", "children", "isVisibleElement", "isVisible", "collectFocusableElements", "nodes", "el", "tabIndex", "needsSort", "childNodes", "i", "getFocusableElements", "sortByTabIndex", "deepContains", "el", "targetEl", "containsTarget", "checkChildren", "elem", "i", "child", "keyCodes", "rotateFocus", "rootElement", "els", "getFocusableElements", "boundaryEls", "first", "last", "activeElement", "getDeepActiveElement", "containFocus", "focusableElements", "initialFocus", "e", "tabDetectionElement", "rootElementMutationObserver", "handleKeydown", "keyCodes", "createHelpersDetectingTabDirection", "mutationsList", "mutation", "tabDetectionElIsMissing", "el", "foundTabDetectionElInMutations", "isForwardTabInWindow", "setFocusInRootElement", "resetToRoot", "deepContains", "nextActive", "handleFocusin", "handleFocusout", "disconnect", "preloadPopper", "GLOBAL_OVERLAYS_CONTAINER_CLASS", "GLOBAL_OVERLAYS_CLASS", "supportsCSSTypedObject", "OverlayController", "_OverlayController", "EventTargetShim", "config", "manager", "overlays", "value", "cfgToAdd", "newConfig", "isInsideRenderTarget", "nodeContainsTarget", "phase", "zIndexNumber", "node", "attrs", "attrMap", "attrName", "elementToFocusAfterHide", "resolve", "event", "addOrRemove", "placementClass", "bodyStyle", "scrollbarWidth", "scrollbarHeight", "newMarginRight", "newMarginBottom", "hideConfig", "afterFadeOut", "showConfig", "activeElement", "insertionAnchor", "insertionBefore", "containFocus", "findNewTrap", "ev", "referenceWidth", "addOrRemoveListener", "wasMouseDownInside", "wasMouseUpInside", "createPopper", "isEqualConfig", "a", "b", "aProps", "bProps", "isEqual", "prop", "OverlayMixinImplementation", "superclass", "value", "shouldUpdate", "isEqualConfig", "name", "oldValue", "contentNode", "invokerNode", "referenceNode", "backdropNode", "contentWrapperNode", "overlayConfig", "OverlayController", "changedProperties", "ev", "child", "newOpened", "beforeShowEvent", "event", "beforeHideEvent", "ctrl", "OverlayMixin", "dedupeMixin", "withModalDialogConfig", "LionDialog", "OverlayMixin", "s", "withModalDialogConfig", "x", "LionDialog"]
}
